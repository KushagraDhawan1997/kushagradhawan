---
alwaysApply: true
---

# Cursor Rules – React + TypeScript

You are my pair-programmer in a modern React + TypeScript codebase (likely Next.js / Vite).  
Assume: function components, hooks, strict TypeScript, and a focus on correctness, DX, and performance.

When you generate or edit code, **follow these principles even if the user doesn’t restate them.**

---

## 1. TypeScript & Types

- **Avoid `any` and `as any`.** Treat them as code smells.

  - Prefer proper types, generics, or `unknown` plus runtime narrowing.
  - If you _must_ use `any` (rare), isolate it in a small, well-documented utility.

- **Minimize type assertions (`as Foo`)**.

  - Prefer proper typing of values at source (e.g., API client types) over casting later.
  - If using assertions, add a comment why it’s safe.

- **Use explicit types for public surfaces:**

  - Component props: `type Props = { ... }` or `interface Props { ... }`.
  - Custom hooks return types.
  - Utility function params/returns.

- **Leverage inference for internals.**

  - Let TS infer local variables and intermediate values.
  - Don’t over-annotate obvious stuff.

- **No `non-null assertion` (`!`) unless unavoidable.**
  - Prefer null checks or narrowing. If asserting non-null, justify in a comment and keep the scope tiny.

---

## 2. Component Design

- **Prefer small, focused components.**

  - Each component should have a single clear responsibility.
  - Extract subcomponents when JSX gets too nested or props too numerous.

- **Use function components + hooks only. No class components.**

- **Good props design:**

  - Avoid giant “bags of props”. If there are > 7–8 props, consider grouping into objects or refactoring.
  - Avoid booleans that explode permutations; consider variants or enums.

- **No business logic in JSX.**
  - Precompute values before the `return`.
  - Mapping, filtering, complex conditionals → move into well-named helpers.

---

## 3. State Management

- **Keep state as local as possible.**

  - Start with component state. Only lift state when multiple descendants truly need it.
  - Avoid premature global state solutions.

- **Avoid prop drilling more than 2–3 levels.**

  - Options: composition, context (sparingly), or dedicated hooks.

- **Use context carefully.**

  - Don’t shove “everything” into a global context.
  - Make contexts narrow and purpose-driven (auth, theme, feature-specific etc.).
  - Always type context values clearly and handle “no provider” cases explicitly.

- **Derived state belongs in selectors/memos, not `useState`.**
  - No duplicated state that can be computed from existing state/props.

---

## 4. Side Effects & `useEffect`

> Default stance: **avoid `useEffect` unless it’s genuinely a side-effect.**

- **Do NOT fetch data in `useEffect` by default.**

  - Prefer:
    - Framework loaders / server components (Next.js loader, RSC, etc.), or
    - Data libraries like React Query / SWR.
  - Only fall back to `useEffect`+`fetch` for truly ad hoc or one-off cases.

- **UseEffect is for:**

  - Subscribing/unsubscribing to external systems (websockets, event listeners).
  - Imperative interactions with non-React APIs (e.g. `document`, `window`, third-party widgets).
  - Syncing state to external storage (localStorage) in a controlled way.

- **Avoid these anti-patterns in `useEffect`:**

  - Computing _derived values_ that could live in `useMemo` or plain variables.
  - Triggering re-renders by setting state from props when it can be computed.
  - “Syncing” props to state without strong justification.

- **Always define the correct dependencies.**

  - No empty `[]` when values are used inside.
  - No disabling of ESLint `react-hooks/exhaustive-deps` just to “make it work”.
  - If you intentionally omit deps, explain why with a comment.

- **Cleanup functions on unmount.**
  - Remove event listeners, abort fetch controllers, cancel subscriptions, etc.

---

## 5. Data Fetching

- **Prefer declarative data fetching approaches:**

  - Use React Query / SWR / framework data APIs for server data.
  - Co-locate queries with the components that need them but keep API clients reusable.

- **No ad-hoc fetch logic repeated everywhere.**

  - Centralize API client configuration (base URL, interceptors, auth headers).
  - Reuse typed API methods instead of raw `fetch` calls.

- **Type-safe APIs.**

  - Define request/response types for each endpoint.
  - Parse/validate external data (e.g. Zod) at boundaries when reasonable.

- **Handle loading and error states explicitly.**
  - No “invisible” failures. Surface errors with sensible UI and logging.

---

## 6. Hooks

- **Custom hooks first-class citizen.**

  - Whenever logic is reused across components, extract into `useXxx` hooks.
  - Hooks should encapsulate behavior + data, not UI.

- **Hook rules:**

  - Follow the Rules of Hooks strictly (no conditional calls).
  - Keep hooks focused; avoid “god hooks” that do too many things.

- **Performance hooks:**
  - Use `useMemo` and `useCallback` **only** when:
    - There’s a proven/likely perf problem, or
    - Referencing them in dependencies (`useEffect`, `useMemo`, `useCallback`) requires stable identity.
  - Avoid sprinkling `useCallback` on every handler.

---

## 7. Performance & Rendering

- **Prefer simplicity first; optimize when needed.**

- When optimizing:

  - Use `React.memo` on components that:
    - Are pure, and
    - Render often with same props, and
    - Are expensive or numerous.
  - Stabilize props passed to memoized components (`useMemo` for objects/arrays passed down).

- **Avoid unnecessary re-renders:**

  - Don’t create new inline objects/arrays in JSX in hot paths if children are memoized.
  - Don’t store large derived objects in state; derive them when needed.

- **Code-splitting:**
  - Use dynamic import / lazy loading for large, rarely used parts (modals, heavy pages).

---

## 8. Styling

- Assume a utility/CSS-in-JS setup (e.g. Tailwind, CSS Modules, or a design system).
- **Keep styling consistent:**

  - Use shared components for common patterns (Button, Modal, Input).
  - Don’t inline raw styles when a design-system component exists.

- **No random one-off styles.**

  - If a pattern repeats, extract it.

- **Avoid deeply nested CSS.**
  - Prefer composition and small, reusable style units.

---

## 9. Accessibility & UX

- **Semantics first:**

  - Use proper HTML elements: `button` for clickable, `a` for navigation, lists for lists, headings in order.
  - No `div`-buttons with click handlers.

- **Keyboard accessibility:**

  - Ensure focus states are visible.
  - Support Enter/Space where appropriate.
  - Manage focus on modals, dialogs, and key flows.

- **ARIA only when needed.**

  - Don’t sprinkle ARIA roles where native semantics suffice.
  - When using ARIA, follow spec: `aria-*` attributes must make sense.

- **Forms:**
  - Every input must have a label.
  - Provide error messages and associate them properly.

---

## 10. Testing

- **Use React Testing Library for component/integration tests.**

  - Test behavior and user-visible outcomes over implementation details.
  - Avoid testing internal state or hook internals directly.

- **Prefer fewer high-value tests over many fragile ones.**

  - Cover critical paths, edge cases, and regressions.

- **No snapshot tests for complex UIs by default.**
  - Use snapshots for simple, stable outputs only.

---

## 11. Project Structure & DX

- **Co-locate related files.**

  - Component + subcomponents + hooks + styles live together when it improves cohesion.
  - Avoid giant “components” or “utils” dumping grounds.

- **Naming:**

  - Components: `PascalCase`.
  - Hooks: `useCamelCase`.
  - Files follow default export name or clear domain name.

- **Imports:**

  - Use absolute imports where supported.
  - Group imports: external libs, shared internal, local.

- **Linting & formatting:**
  - Always respect ESLint and Prettier config.
  - If a rule is painful, fix the underlying issue or justify changing the rule—don’t disable inline without reason.

---

## 12. Error Handling & Logging

- **No empty catch blocks.**

  - Log errors appropriately, surface user-friendly messages.
  - Avoid leaking sensitive info to the UI; keep detailed logs to console/monitoring.

- **Use error boundaries where appropriate.**

  - Wrap large sections/pages that can fail independently.

- **Avoid console noise in production.**
  - Use logging utilities or environment-guarded logs if needed.

---

## 13. Comments & Documentation

- **Comment “why”, not “what”.**

  - Code should explain _what_; comments explain _why_ it’s done that way.

- **Document tricky hooks and components.**
  - Short JSDoc for custom hooks and complex utilities is appreciated.
  - If there’s a non-obvious constraint, document it.

---

## 14. When in Doubt

When there are multiple ways to implement something:

1. Prefer readability and maintainability.
2. Prefer patterns already established in the codebase.
3. Avoid clever one-liners that are hard to understand.
4. Respect the rules above even if the immediate request pushes in a worse direction—nudge the solution toward these standards.

If a user request conflicts with these rules, **adapt the request to fit these principles** rather than ignoring them.
